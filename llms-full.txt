# PyEzTrace

> Lightweight Python tracing and logging with hierarchical output and an interactive viewer

Lightweight Python tracing and logging documentation for PyEzTrace.

# Documentation

# PyEzTrace

Dependency-free tracing, structured logs, and an interactive viewer for understanding real execution paths.

[Get Started](https://jeffersonaaron25.github.io/pyeztrace/getting-started) [Explore Usage](https://jeffersonaaron25.github.io/pyeztrace/usage)

## Why teams use PyEzTrace

### Hierarchical traces

Tree-style output makes nested execution paths readable without extra tooling.

### Flexible log formats

Color, plain, JSON, CSV, and logfmt support one code path from local dev to production.

### Runtime metrics

Collect timing data and context propagation details where latency and failures actually happen.

### Interactive viewer

Inspect input/output previews, CPU, and memory from trace logs in a focused web UI.

> **Note:** The trace viewer UI (`pyeztrace serve`) is designed for **local development and analysis**—it is **not** intended to be used as a hosted or production solution.

## Quick start

```
from pyeztrace.setup import Setup
from pyeztrace import trace
from pyeztrace.custom_logging import Logging

Setup.initialize("MyApp", show_metrics=True, log_format="json", log_dir="logs", log_file="app.log")
log = Logging()

@trace()
def process_order(order_id):
    with log.with_context(order_id=order_id):
        log.log_info("Processing order")
        # ... your code ...
```

Run your app, then open the trace viewer:

```
pyeztrace serve logs/app.log --host 127.0.0.1 --port 8765
# open http://127.0.0.1:8765
```

## Next steps

- [Getting Started](https://jeffersonaaron25.github.io/pyeztrace/getting-started/index.md) - Installation and initialization
- [Usage](https://jeffersonaaron25.github.io/pyeztrace/usage/index.md) - Tracing, context, formats, viewer, and async support
- [Configuration](https://jeffersonaaron25.github.io/pyeztrace/configuration/index.md) - Environment variables and `Setup.initialize()` options

# Getting Started

## Installation

```
pip install pyeztrace
```

Optional extras (library stays dependency-free by default):

| Extra              | Purpose                                 |
| ------------------ | --------------------------------------- |
| `pyeztrace[otel]`  | OpenTelemetry SDK and OTLP exporter     |
| `pyeztrace[gcp]`   | Google ADC auth for OTLP to Cloud Trace |
| `pyeztrace[s3]`    | S3 exporter for span batches            |
| `pyeztrace[azure]` | Azure Blob exporter                     |
| `pyeztrace[all]`   | All optional dependencies               |

For the full test suite including OTEL coverage:

```
pip install "pyeztrace[otel]"
```

## Initialize once at startup

Recommended: call `Setup.initialize(...)` before any traced code runs. Logging is configured once; doing this first gives predictable behavior.

```
from pyeztrace.setup import Setup
from pyeztrace import trace
from pyeztrace.custom_logging import Logging

Setup.initialize(
    "MyApp",
    show_metrics=True,
    log_format="json",
    log_file="app.log",
    log_dir="logs",
    disable_file_logging=False,
)
log = Logging()
```

## Initialization order

- Importing `trace` does **not** initialize setup; initialization is lazy on first use.
- For predictable behavior, either:
- Set **environment variables** before process start (e.g. `EZTRACE_LOG_DIR=logs`, `EZTRACE_LOG_FILE=app.log`), or
- Call **`Setup.initialize(...)`** before the first traced call.

Configuration precedence (highest to lowest):

1. Arguments passed to `Setup.initialize(...)`
1. Environment variables (`EZTRACE_*`)
1. Built-in defaults

## Quick example

```
@trace()
def process_order(order_id):
    with log.with_context(order_id=order_id):
        log.log_info("Processing order")
        validate_order(order_id)
        log.log_info("Order processed successfully")

@trace()
def validate_order(order_id):
    log.log_info("Validating order")
    # your logic
```

Example console output (with `log_format="color"` or `"plain"`):

```
2025-05-13T10:00:00 - INFO - [MyApp] ├── process_order called...
2025-05-13T10:00:00 - INFO - [MyApp] ├── Processing order Data: {order_id: "123"}
2025-05-13T10:00:00 - INFO - [MyApp] │    ├─── validate_order called...
2025-05-13T10:00:00 - INFO - [MyApp] │    ├─── validate_order Ok. (took 0.50 seconds)
2025-05-13T10:00:01 - INFO - [MyApp] ├── process_order Ok. (took 1.23 seconds)
```

See [Usage](https://jeffersonaaron25.github.io/pyeztrace/usage/index.md) for tracing options, formats, CLI, and the interactive viewer.

# Usage

## Tracing options

Fine-grained control with the `@trace()` decorator:

```
@trace(
    message="Custom trace message",
    stack=True,  # Include stack trace on errors
    sample_rate=0.5,  # Optional local override for this trace
    adaptive_sampling=True,  # Optional local adaptive override
    adaptive_slow_threshold=0.25,  # Optional local slow-threshold override (seconds)
    modules_or_classes=[my_module],
    include=["specific_function_*"],
    exclude=["ignored_function_*"],
    recursive_depth=2,
    module_pattern="myapp.*",
)
def function():
    pass
```

### Sampling

Global env controls:

- `EZTRACE_SAMPLE_RATE` (`0.0` to `1.0`, default `1.0`)
- `EZTRACE_ADAPTIVE_SAMPLING` (`true`/`false`, default `false`)
- `EZTRACE_ADAPTIVE_SLOW_THRESHOLD` (seconds, `>= 0.0`, default `1.0`)

Local override:

```
@trace(
    sample_rate=1.0,            # Force this trace to always be kept
    adaptive_sampling=True,     # Local adaptive mode override
    adaptive_slow_threshold=0.1 # Local slow threshold override
)
def critical_path():
    pass
```

Adaptive mode keeps slow/error traces at 100% and samples normal traces using the configured rate.

### Recursive tracing

Trace the function and functions in imported modules:

```
@trace(recursive_depth=1, module_pattern="myapp.*")
def app_entry():
    # Traces this and matching imported modules
    pass
```

Use `module_pattern` to avoid tracing system or third-party code.

### Redacting sensitive data

```
@trace(
    redact_keys=["password", "token"],
    redact_value_patterns=[r"secret\d+"],
    redact_presets=["pii"],
)
def process(user, password, token):
    return {"user": user, "status": "ok"}
```

Environment defaults: `EZTRACE_REDACT_KEYS`, `EZTRACE_REDACT_PATTERN`, `EZTRACE_REDACT_VALUE_PATTERNS`, `EZTRACE_REDACT_PRESETS`.

## Context management

Thread-safe context propagation:

```
with log.with_context(user_id="123", action="login"):
    log.log_info("User logged in")  # Includes context

    with log.with_context(session="abc"):
        log.log_info("Session started")  # Inherits parent context
```

## Output formats

| Format   | Use case                                  |
| -------- | ----------------------------------------- |
| `color`  | Default console; hierarchical tree        |
| `json`   | Machine-readable; required for the viewer |
| `plain`  | Simple text                               |
| `csv`    | Spreadsheet analysis                      |
| `logfmt` | System-style key=value                    |

```
log = Logging(log_format="json")  # or "color", "plain", "csv", "logfmt"
```

Per-sink: set `console_format` and `file_format` via `Setup.initialize(..., console_format="color", file_format="json")` or env `EZTRACE_CONSOLE_LOG_FORMAT` / `EZTRACE_FILE_LOG_FORMAT`.

## Interactive viewer

1. Enable JSON file logging (e.g. `Setup.initialize(..., file_format="json", disable_file_logging=False)`).
1. Run your app to produce logs.
1. Start the viewer:

```
pyeztrace serve logs/app.log --host 127.0.0.1 --port 8765
```

Open `http://127.0.0.1:8765`. You get:

- Hierarchical tree (parent/child calls)
- Input/output previews, duration, CPU, memory
- Filters (function, error, min duration), auto-refresh

> **Note:** The trace viewer UI (`pyeztrace serve`) is designed for **local development and analysis**—it is **not** intended to be used as a hosted or production solution.

## Async support

```
@trace()
async def async_handler():
    await some_async_work()
    log.log_info("Done")
```

Setup and level tracking are async-safe.

## Redirecting `print` to logging

```
from pyeztrace import print  # noqa: A001

Setup.initialize("MyApp")
print("Hello")                      # INFO
print("Warning", level="WARNING")  # WARNING
```

Falls back to built-in `print` if EzTrace is not initialized or when writing to a custom file.

## Performance metrics

```
Setup.initialize("MyApp", show_metrics=True)

@trace()
def monitored():
    pass
```

At exit, a summary is printed: calls, total time, average per function.

## Error handling

```
log.log_debug("Debug")
log.log_info("Info")
log.log_warning("Warning")
log.log_error("Error")

try:
    risky()
except Exception as e:
    log.raise_exception_to_log(e, "Custom message", stack=True)
```

## Applying `@trace` to classes

Decorate a class to trace all its methods (including `__init__`):

```
from pyeztrace import trace

@trace()
class MyService:
    def __init__(self, name):
        self.name = name

    def process(self, data):
        return data.upper()

    def analyze(self, data):
        return len(data)
```

Each method gets full tracing (start/end, duration, args/result preview).

## Double-tracing prevention

PyEzTrace avoids duplicate trace entries when:

- A function is decorated with `@trace` and also called from another traced function
- A class is decorated and also traced via recursive tracing
- The same function is traced from multiple parent functions (recursive tracing)

Only one trace is emitted per call, so logs stay clean while coverage stays full.

## Thread-safe high-volume logging

The logger and tracer are thread-safe. Example with a thread pool:

```
from concurrent.futures import ThreadPoolExecutor
from pyeztrace import trace
from pyeztrace.custom_logging import Logging

log = Logging()

@trace()
def worker(worker_id):
    with log.with_context(worker_id=worker_id):
        log.log_info("Started")
        # ... work ...
        log.log_info("Finished")

with ThreadPoolExecutor(max_workers=5) as executor:
    executor.map(worker, range(5))
```

## Global redaction (programmatic)

Set default redaction for all traces in code:

```
from pyeztrace import set_global_redaction

set_global_redaction(
    redact_keys=["password", "token"],
    redact_pattern=r"(?i)secret",
    redact_value_patterns=[r"secret\d+"],
    presets=["pii"],
)
```

Same options as per-decorator `redact_keys`, `redact_pattern`, `redact_value_patterns`, and `redact_presets`.

## CLI

| Command                      | Description                                                         |
| ---------------------------- | ------------------------------------------------------------------- |
| `pyeztrace serve <log_file>` | Start the interactive trace viewer (default: http://127.0.0.1:8765) |
| `pyeztrace print <log_file>` | Print or filter log entries from a file                             |

**Viewer:**

```
pyeztrace serve logs/app.log --host 127.0.0.1 --port 8765
```

Optional env: `EZTRACE_VIEW_HOST`, `EZTRACE_VIEW_PORT`.

**Print / analyze logs:**

```
pyeztrace print logs/app.log
pyeztrace print logs/app.log --analyze
pyeztrace print logs/app.log --function my_func --format json
```

Use `--level`, `--since`, `--until` to filter. `--analyze` shows performance metrics; `--function` limits analysis to that function.

## OpenTelemetry (optional)

Install: `pip install "pyeztrace[otel]"`. Enable with environment variables.

**OTLP (collector):**

```
export EZTRACE_OTEL_ENABLED=true
export EZTRACE_OTEL_EXPORTER=otlp
export EZTRACE_OTLP_ENDPOINT="http://localhost:4318/v1/traces"
# optional: export EZTRACE_SERVICE_NAME="my-service"
```

**Google Cloud Trace (OTLP + ADC):**

```
pip install "pyeztrace[otel,gcp]"
export EZTRACE_OTEL_ENABLED=true
export EZTRACE_OTEL_EXPORTER=gcp
# optional override; defaults to telemetry endpoint for exporter=gcp
export EZTRACE_OTLP_ENDPOINT="https://telemetry.googleapis.com/v1/traces"
# optional explicit toggle
export EZTRACE_OTLP_GCP_AUTH=true
```

If Cloud Trace returns `Resource is missing required attribute "gcp.project_id"`, set: `EZTRACE_GCP_PROJECT_ID` (or `GOOGLE_CLOUD_PROJECT` / `GCLOUD_PROJECT` / `GCP_PROJECT`).

**Console (local dev):**

```
export EZTRACE_OTEL_ENABLED=true
export EZTRACE_OTEL_EXPORTER=console
```

**S3 / Azure:** Install `pyeztrace[s3]` or `pyeztrace[azure]`, set `EZTRACE_OTEL_EXPORTER=s3` or `azure`, and the bucket/container and credential env vars. See the [README OpenTelemetry section](https://github.com/jeffersonaaron25/pyeztrace#10-opentelemetry-spans-optional) for full S3/Azure options.

The bridge is lazy-loaded; if OTEL packages are missing, the library still works without spans. Spans use function `__qualname__`; exceptions are recorded on the active span.

For troubleshooting, enable OTEL diagnostics:

```
export EZTRACE_OTEL_DEBUG=true
```

And inspect runtime OTEL state in code:

```
from pyeztrace import otel
print(otel.get_otel_status())
```

`otel.get_otel_status()` is available in newer builds after `0.1.1`.

# Configuration

All options can be set via **environment variables** or **code**. Precedence: `Setup.initialize(...)` kwargs > env vars > defaults.

## Via `Setup.initialize()`

Recommended for applications:

```
from pyeztrace.setup import Setup

Setup.initialize(
    "MyApp",
    show_metrics=True,
    disable_file_logging=False,
    log_format="json",
    console_format="color",
    file_format="json",
    log_level="DEBUG",
    log_file="app.log",
    log_dir="logs",
    max_size=10 * 1024 * 1024,  # 10MB
    backup_count=5,
    buffer_enabled=False,
    buffer_flush_interval=1.0,
)
```

## Via environment variables

```
export EZTRACE_LOG_FORMAT="json" # legacy: sets both console and file
export EZTRACE_CONSOLE_LOG_FORMAT="color"
export EZTRACE_FILE_LOG_FORMAT="json"
export EZTRACE_LOG_LEVEL="DEBUG"
export EZTRACE_LOG_FILE="app.log"
export EZTRACE_LOG_DIR="logs"
export EZTRACE_MAX_SIZE="10485760" # 10MB
export EZTRACE_BACKUP_COUNT="5" # Keep 5 rotated files
export EZTRACE_DISABLE_FILE_LOGGING="0"
export EZTRACE_BUFFER_ENABLED="false" # Disable buffering by default (configurable via env)
export EZTRACE_BUFFER_FLUSH_INTERVAL="1.0" # Seconds between flushes when buffering
export EZTRACE_SAMPLE_RATE="1.0" # Global fixed sampling rate in [0.0, 1.0]
export EZTRACE_ADAPTIVE_SAMPLING="false" # Keep slow/error traces at 100%, sample normal traces
export EZTRACE_ADAPTIVE_SLOW_THRESHOLD="1.0" # Seconds; slow traces are always kept when adaptive is enabled
```

Set these **before** the first traced or logging use so they apply when the logger is created.

## Console-only (no file logging)

```
export EZTRACE_DISABLE_FILE_LOGGING=1
```

Or in code:

```
Setup.initialize("MyApp", disable_file_logging=True)
```

## Log rotation

Log files are rotated by size. Configure before first use:

```
# In Setup.initialize()
max_size=10 * 1024 * 1024,  # 10MB per file
backup_count=5,              # Keep 5 rotated files
log_dir="logs",
log_file="app.log",
```

Env: `EZTRACE_MAX_SIZE`, `EZTRACE_BACKUP_COUNT`, `EZTRACE_LOG_DIR`, `EZTRACE_LOG_FILE`.

## Buffered logging

When enabled, log records are buffered and flushed on interval or buffer full. Reduces I/O under high volume.

- **Env:** `EZTRACE_BUFFER_ENABLED=true`, `EZTRACE_BUFFER_FLUSH_INTERVAL=1.0`
- **Code:** `Setup.initialize(..., buffer_enabled=True, buffer_flush_interval=1.0)`

Default is disabled. Set before the first traced/logging use.

## Redaction (env defaults)

```
export EZTRACE_REDACT_KEYS="password,token,secret"
export EZTRACE_REDACT_PATTERN="(?i)auth|secret"
export EZTRACE_REDACT_VALUE_PATTERNS="secret\d+"
export EZTRACE_REDACT_PRESETS="pii,phi"
```

For programmatic defaults, use `set_global_redaction()` — see [Usage: Global redaction](https://jeffersonaaron25.github.io/pyeztrace/usage/#global-redaction-programmatic).

## Sampling

- **Global fixed sampling:** `EZTRACE_SAMPLE_RATE` (float from `0.0` to `1.0`, default `1.0`)
- **Global adaptive mode:** `EZTRACE_ADAPTIVE_SAMPLING` (`true`/`false`, default `false`)
- **Global adaptive slow threshold:** `EZTRACE_ADAPTIVE_SLOW_THRESHOLD` (float seconds, `>= 0.0`, default `1.0`)

When adaptive sampling is enabled, slow/error traces are always kept; normal traces use the configured sample rate.

# Contributing

Contributions are welcome. Please read the **Contributing Guidelines** ([CONTRIBUTING.md](https://github.com/jeffersonaaron25/pyeztrace/blob/main/CONTRIBUTING.md)) in the repository for:

- Code of conduct
- How to submit pull requests
- Development and testing setup
